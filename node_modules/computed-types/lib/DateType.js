"use strict";

exports.__esModule = true;
exports.default = exports.DateValidator = void 0;

var _Validator = _interopRequireDefault(require("./Validator"));

var _string = require("./string");

var _errors = require("./schema/errors");

var _number = require("./number");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

class DateValidator extends _Validator.default {
  constructor(...args) {
    super(...args);
    this.gte = this.min;
    this.lte = this.max;
  }

  toISOString(...args) {
    return this.transform(val => val.toISOString(...args), _string.StringValidator);
  }

  getTime(...args) {
    return this.transform(val => val.getTime(...args), _number.NumberValidator);
  }

  min(min, error) {
    return this.test(val => val >= min, error || (val => new RangeError(`Expect date to be greater or equal than ${min} (actual: ${val})`)));
  }

  max(max, error) {
    return this.test(val => val <= max, error || (val => new RangeError(`Expect date to be lower or equal than ${max} (actual: ${val})`)));
  }

  gt(boundary, error) {
    return this.test(val => val > boundary, error || (val => new RangeError(`Expect date to be greater than ${boundary} (actual: ${val})`)));
  }

  lt(boundary, error) {
    return this.test(val => val < boundary, error || (val => new RangeError(`Expect date to be lower than ${boundary} (actual: ${val})`)));
  }

  between(min, max, error) {
    return this.test(val => val >= min && val <= max, error || (val => new RangeError(`Expect date to be between ${min} and ${max} (actual: ${val})`)));
  }

}

exports.DateValidator = DateValidator;
const DateType = new DateValidator(input => {
  if (!(input instanceof Date)) {
    throw (0, _errors.toError)(`Expect value to be instance of Date`);
  }

  return input;
}).proxy();
var _default = DateType;
exports.default = _default;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uL3NyYy9EYXRlVHlwZS50cyJdLCJuYW1lcyI6WyJEYXRlVmFsaWRhdG9yIiwiVmFsaWRhdG9yIiwiZ3RlIiwibWluIiwibHRlIiwibWF4IiwidG9JU09TdHJpbmciLCJhcmdzIiwidHJhbnNmb3JtIiwidmFsIiwiU3RyaW5nVmFsaWRhdG9yIiwiZ2V0VGltZSIsIk51bWJlclZhbGlkYXRvciIsImVycm9yIiwidGVzdCIsIlJhbmdlRXJyb3IiLCJndCIsImJvdW5kYXJ5IiwibHQiLCJiZXR3ZWVuIiwiRGF0ZVR5cGUiLCJpbnB1dCIsIkRhdGUiLCJwcm94eSJdLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBQTs7QUFDQTs7QUFDQTs7QUFFQTs7OztBQUVPLE1BQU1BLGFBQU4sU0FFR0Msa0JBRkgsQ0FFb0M7QUFBQTtBQUFBO0FBQUEsU0FtQ2xDQyxHQW5Da0MsR0FtQzVCLEtBQUtDLEdBbkN1QjtBQUFBLFNBb0NsQ0MsR0FwQ2tDLEdBb0M1QixLQUFLQyxHQXBDdUI7QUFBQTs7QUFDbENDLEVBQUFBLFdBQVcsQ0FDaEIsR0FBR0MsSUFEYSxFQUVvQjtBQUNwQyxXQUFPLEtBQUtDLFNBQUwsQ0FBZ0JDLEdBQUQsSUFBU0EsR0FBRyxDQUFDSCxXQUFKLENBQWdCLEdBQUdDLElBQW5CLENBQXhCLEVBQWtERyx1QkFBbEQsQ0FBUDtBQUNEOztBQUVNQyxFQUFBQSxPQUFPLENBQ1osR0FBR0osSUFEUyxFQUV3QjtBQUNwQyxXQUFPLEtBQUtDLFNBQUwsQ0FBZ0JDLEdBQUQsSUFBU0EsR0FBRyxDQUFDRSxPQUFKLENBQVksR0FBR0osSUFBZixDQUF4QixFQUE4Q0ssdUJBQTlDLENBQVA7QUFDRDs7QUFFTVQsRUFBQUEsR0FBRyxDQUFDQSxHQUFELEVBQVlVLEtBQVosRUFBNkQ7QUFDckUsV0FBTyxLQUFLQyxJQUFMLENBQ0pMLEdBQUQsSUFBU0EsR0FBRyxJQUFJTixHQURYLEVBRUxVLEtBQUssS0FDREosR0FBRCxJQUNDLElBQUlNLFVBQUosQ0FDRywyQ0FBMENaLEdBQUksYUFBWU0sR0FBSSxHQURqRSxDQUZDLENBRkEsQ0FBUDtBQVFEOztBQUVNSixFQUFBQSxHQUFHLENBQUNBLEdBQUQsRUFBWVEsS0FBWixFQUE2RDtBQUNyRSxXQUFPLEtBQUtDLElBQUwsQ0FDSkwsR0FBRCxJQUFTQSxHQUFHLElBQUlKLEdBRFgsRUFFTFEsS0FBSyxLQUNESixHQUFELElBQ0MsSUFBSU0sVUFBSixDQUNHLHlDQUF3Q1YsR0FBSSxhQUFZSSxHQUFJLEdBRC9ELENBRkMsQ0FGQSxDQUFQO0FBUUQ7O0FBS01PLEVBQUFBLEVBQUUsQ0FBQ0MsUUFBRCxFQUFpQkosS0FBakIsRUFBa0U7QUFDekUsV0FBTyxLQUFLQyxJQUFMLENBQ0pMLEdBQUQsSUFBU0EsR0FBRyxHQUFHUSxRQURWLEVBRUxKLEtBQUssS0FDREosR0FBRCxJQUNDLElBQUlNLFVBQUosQ0FDRyxrQ0FBaUNFLFFBQVMsYUFBWVIsR0FBSSxHQUQ3RCxDQUZDLENBRkEsQ0FBUDtBQVFEOztBQUVNUyxFQUFBQSxFQUFFLENBQUNELFFBQUQsRUFBaUJKLEtBQWpCLEVBQWtFO0FBQ3pFLFdBQU8sS0FBS0MsSUFBTCxDQUNKTCxHQUFELElBQVNBLEdBQUcsR0FBR1EsUUFEVixFQUVMSixLQUFLLEtBQ0RKLEdBQUQsSUFDQyxJQUFJTSxVQUFKLENBQ0csZ0NBQStCRSxRQUFTLGFBQVlSLEdBQUksR0FEM0QsQ0FGQyxDQUZBLENBQVA7QUFRRDs7QUFFTVUsRUFBQUEsT0FBTyxDQUNaaEIsR0FEWSxFQUVaRSxHQUZZLEVBR1pRLEtBSFksRUFJVTtBQUN0QixXQUFPLEtBQUtDLElBQUwsQ0FDSkwsR0FBRCxJQUFTQSxHQUFHLElBQUlOLEdBQVAsSUFBY00sR0FBRyxJQUFJSixHQUR6QixFQUVMUSxLQUFLLEtBQ0RKLEdBQUQsSUFDQyxJQUFJTSxVQUFKLENBQ0csNkJBQTRCWixHQUFJLFFBQU9FLEdBQUksYUFBWUksR0FBSSxHQUQ5RCxDQUZDLENBRkEsQ0FBUDtBQVFEOztBQXpFd0M7OztBQTRFM0MsTUFBTVcsUUFBUSxHQUFHLElBQUlwQixhQUFKLENBQW1CcUIsS0FBRCxJQUFXO0FBQzVDLE1BQUksRUFBRUEsS0FBSyxZQUFZQyxJQUFuQixDQUFKLEVBQThCO0FBQzVCLFVBQU0scUJBQVMscUNBQVQsQ0FBTjtBQUNEOztBQUVELFNBQU9ELEtBQVA7QUFDRCxDQU5nQixFQU1kRSxLQU5jLEVBQWpCO2VBUWVILFEiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgVmFsaWRhdG9yLCB7IFZhbGlkYXRvclByb3h5IH0gZnJvbSAnLi9WYWxpZGF0b3InO1xuaW1wb3J0IHsgU3RyaW5nVmFsaWRhdG9yIH0gZnJvbSAnLi9zdHJpbmcnO1xuaW1wb3J0IHsgRXJyb3JMaWtlLCB0b0Vycm9yIH0gZnJvbSAnLi9zY2hlbWEvZXJyb3JzJztcbmltcG9ydCBGdW5jdGlvblR5cGUsIHsgRnVuY3Rpb25QYXJhbWV0ZXJzIH0gZnJvbSAnLi9zY2hlbWEvRnVuY3Rpb25UeXBlJztcbmltcG9ydCB7IE51bWJlclZhbGlkYXRvciB9IGZyb20gJy4vbnVtYmVyJztcblxuZXhwb3J0IGNsYXNzIERhdGVWYWxpZGF0b3I8XG4gIFAgZXh0ZW5kcyBGdW5jdGlvblBhcmFtZXRlcnMgPSBbRGF0ZV0sXG4+IGV4dGVuZHMgVmFsaWRhdG9yPEZ1bmN0aW9uVHlwZTxEYXRlLCBQPj4ge1xuICBwdWJsaWMgdG9JU09TdHJpbmcoXG4gICAgLi4uYXJnczogUGFyYW1ldGVyczxEYXRlWyd0b0lTT1N0cmluZyddPlxuICApOiBWYWxpZGF0b3JQcm94eTxTdHJpbmdWYWxpZGF0b3I8UD4+IHtcbiAgICByZXR1cm4gdGhpcy50cmFuc2Zvcm0oKHZhbCkgPT4gdmFsLnRvSVNPU3RyaW5nKC4uLmFyZ3MpLCBTdHJpbmdWYWxpZGF0b3IpO1xuICB9XG5cbiAgcHVibGljIGdldFRpbWUoXG4gICAgLi4uYXJnczogUGFyYW1ldGVyczxEYXRlWydnZXRUaW1lJ10+XG4gICk6IFZhbGlkYXRvclByb3h5PE51bWJlclZhbGlkYXRvcjxQPj4ge1xuICAgIHJldHVybiB0aGlzLnRyYW5zZm9ybSgodmFsKSA9PiB2YWwuZ2V0VGltZSguLi5hcmdzKSwgTnVtYmVyVmFsaWRhdG9yKTtcbiAgfVxuXG4gIHB1YmxpYyBtaW4obWluOiBEYXRlLCBlcnJvcj86IEVycm9yTGlrZTxbRGF0ZV0+KTogVmFsaWRhdG9yUHJveHk8dGhpcz4ge1xuICAgIHJldHVybiB0aGlzLnRlc3QoXG4gICAgICAodmFsKSA9PiB2YWwgPj0gbWluLFxuICAgICAgZXJyb3IgfHxcbiAgICAgICAgKCh2YWwpOiBSYW5nZUVycm9yID0+XG4gICAgICAgICAgbmV3IFJhbmdlRXJyb3IoXG4gICAgICAgICAgICBgRXhwZWN0IGRhdGUgdG8gYmUgZ3JlYXRlciBvciBlcXVhbCB0aGFuICR7bWlufSAoYWN0dWFsOiAke3ZhbH0pYCxcbiAgICAgICAgICApKSxcbiAgICApO1xuICB9XG5cbiAgcHVibGljIG1heChtYXg6IERhdGUsIGVycm9yPzogRXJyb3JMaWtlPFtEYXRlXT4pOiBWYWxpZGF0b3JQcm94eTx0aGlzPiB7XG4gICAgcmV0dXJuIHRoaXMudGVzdChcbiAgICAgICh2YWwpID0+IHZhbCA8PSBtYXgsXG4gICAgICBlcnJvciB8fFxuICAgICAgICAoKHZhbCk6IFJhbmdlRXJyb3IgPT5cbiAgICAgICAgICBuZXcgUmFuZ2VFcnJvcihcbiAgICAgICAgICAgIGBFeHBlY3QgZGF0ZSB0byBiZSBsb3dlciBvciBlcXVhbCB0aGFuICR7bWF4fSAoYWN0dWFsOiAke3ZhbH0pYCxcbiAgICAgICAgICApKSxcbiAgICApO1xuICB9XG5cbiAgcHVibGljIGd0ZSA9IHRoaXMubWluO1xuICBwdWJsaWMgbHRlID0gdGhpcy5tYXg7XG5cbiAgcHVibGljIGd0KGJvdW5kYXJ5OiBEYXRlLCBlcnJvcj86IEVycm9yTGlrZTxbRGF0ZV0+KTogVmFsaWRhdG9yUHJveHk8dGhpcz4ge1xuICAgIHJldHVybiB0aGlzLnRlc3QoXG4gICAgICAodmFsKSA9PiB2YWwgPiBib3VuZGFyeSxcbiAgICAgIGVycm9yIHx8XG4gICAgICAgICgodmFsKTogUmFuZ2VFcnJvciA9PlxuICAgICAgICAgIG5ldyBSYW5nZUVycm9yKFxuICAgICAgICAgICAgYEV4cGVjdCBkYXRlIHRvIGJlIGdyZWF0ZXIgdGhhbiAke2JvdW5kYXJ5fSAoYWN0dWFsOiAke3ZhbH0pYCxcbiAgICAgICAgICApKSxcbiAgICApO1xuICB9XG5cbiAgcHVibGljIGx0KGJvdW5kYXJ5OiBEYXRlLCBlcnJvcj86IEVycm9yTGlrZTxbRGF0ZV0+KTogVmFsaWRhdG9yUHJveHk8dGhpcz4ge1xuICAgIHJldHVybiB0aGlzLnRlc3QoXG4gICAgICAodmFsKSA9PiB2YWwgPCBib3VuZGFyeSxcbiAgICAgIGVycm9yIHx8XG4gICAgICAgICgodmFsKTogUmFuZ2VFcnJvciA9PlxuICAgICAgICAgIG5ldyBSYW5nZUVycm9yKFxuICAgICAgICAgICAgYEV4cGVjdCBkYXRlIHRvIGJlIGxvd2VyIHRoYW4gJHtib3VuZGFyeX0gKGFjdHVhbDogJHt2YWx9KWAsXG4gICAgICAgICAgKSksXG4gICAgKTtcbiAgfVxuXG4gIHB1YmxpYyBiZXR3ZWVuKFxuICAgIG1pbjogRGF0ZSxcbiAgICBtYXg6IERhdGUsXG4gICAgZXJyb3I/OiBFcnJvckxpa2U8W0RhdGVdPixcbiAgKTogVmFsaWRhdG9yUHJveHk8dGhpcz4ge1xuICAgIHJldHVybiB0aGlzLnRlc3QoXG4gICAgICAodmFsKSA9PiB2YWwgPj0gbWluICYmIHZhbCA8PSBtYXgsXG4gICAgICBlcnJvciB8fFxuICAgICAgICAoKHZhbCk6IFJhbmdlRXJyb3IgPT5cbiAgICAgICAgICBuZXcgUmFuZ2VFcnJvcihcbiAgICAgICAgICAgIGBFeHBlY3QgZGF0ZSB0byBiZSBiZXR3ZWVuICR7bWlufSBhbmQgJHttYXh9IChhY3R1YWw6ICR7dmFsfSlgLFxuICAgICAgICAgICkpLFxuICAgICk7XG4gIH1cbn1cblxuY29uc3QgRGF0ZVR5cGUgPSBuZXcgRGF0ZVZhbGlkYXRvcigoaW5wdXQpID0+IHtcbiAgaWYgKCEoaW5wdXQgaW5zdGFuY2VvZiBEYXRlKSkge1xuICAgIHRocm93IHRvRXJyb3IoYEV4cGVjdCB2YWx1ZSB0byBiZSBpbnN0YW5jZSBvZiBEYXRlYCk7XG4gIH1cblxuICByZXR1cm4gaW5wdXQ7XG59KS5wcm94eSgpO1xuXG5leHBvcnQgZGVmYXVsdCBEYXRlVHlwZTtcbiJdfQ==