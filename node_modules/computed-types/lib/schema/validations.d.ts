import { ErrorLike, ValidationError } from './errors';
import FunctionType, { FunctionParameters } from './FunctionType';
import { Enum, MaybeAsync, ObjectProperty, ResolvedValue, Typeof } from './utils';
export declare function type<T extends keyof Typeof, P extends FunctionParameters = [Typeof[T]]>(type: T, error?: ErrorLike<P>): FunctionType<Typeof[T], P>;
export declare function equals<T, P extends FunctionParameters = [T]>(expected: T, error?: ErrorLike<P>): FunctionType<T, P>;
export declare function test<P extends FunctionParameters>(tester: FunctionType<unknown, P>, error?: ErrorLike<P>): FunctionType<P[0], P>;
export declare function destruct<F extends FunctionType>(validator: F, error?: ErrorLike<Parameters<F>>): FunctionType<MaybeAsync<ReturnType<F>, [
    ValidationError | null,
    ResolvedValue<ReturnType<F>>?
]>, Parameters<F>>;
export declare function error<R, P extends FunctionParameters>(validator: FunctionType<R, P>, err: ErrorLike<P>): FunctionType<R, P>;
export declare function regexp<P extends FunctionParameters = [string]>(exp: RegExp | string, error?: ErrorLike<P>): FunctionType<string, P>;
export declare function array<R extends Array<unknown>, P extends FunctionParameters = [R]>(length?: number | null, error?: ErrorLike<P>): FunctionType<R, P>;
export declare function enumValue<E extends Enum<E>, P extends FunctionParameters = [E[keyof E]]>(value: E, error?: ErrorLike<P>): FunctionType<E[keyof E], P>;
export declare function recordValue<K extends ObjectProperty, V, IK extends ObjectProperty, IV, P extends FunctionParameters = [Record<IK, IV>]>(key: FunctionType<K, [IK]>, value: FunctionType<V, [IV]>, error?: ErrorLike<P>): FunctionType<Record<K, V>, P>;
