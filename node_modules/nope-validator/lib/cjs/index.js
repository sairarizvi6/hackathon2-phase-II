'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

// src/NopeReference.ts
var NopeReference = class {
  constructor(key) {
    this.key = key;
  }
};

// src/utils.ts
function resolvePathFromContext(path, context) {
  const optionWithPath = path.split("../");
  const depth = optionWithPath.length - 1;
  const key = optionWithPath[optionWithPath.length - 1];
  let ctx = context;
  for (let i = 0; i < depth; i++) {
    ctx = ctx?.___parent;
  }
  if (ctx && key !== void 0 && key !== null) {
    return ctx[key];
  }
  return key;
}
function resolveNopeRefsFromKeys(options, context) {
  const resolvedOptions = options.map((option) => {
    return resolvePathFromContext(option, context);
  });
  return resolvedOptions;
}
function resolveNopeRef(option, context) {
  if (option instanceof NopeReference) {
    return resolvePathFromContext(option.key, context);
  }
  return option;
}
function deepEquals(a, b) {
  if (typeof a == "object" && a != null && typeof b == "object" && b != null) {
    if (a === b) {
      return true;
    }
    let aCount = 0;
    let bCount = 0;
    for (const _ in a) {
      aCount++;
    }
    for (const _ in b) {
      bCount++;
    }
    if (aCount - bCount !== 0) {
      return false;
    }
    for (const key in a) {
      if (!(key in b) || !deepEquals(a[key], b[key])) {
        return false;
      }
    }
    for (const key in b) {
      if (!(key in a) || !deepEquals(b[key], a[key])) {
        return false;
      }
    }
    return true;
  }
  return a === b;
}
function pathToArray(path) {
  return path.split(/[,[\].]/g).filter(Boolean);
}
function getFromPath(path, entry, dropLast = false) {
  if (!path) {
    return void 0;
  }
  let pathArray = pathToArray(path);
  pathArray = dropLast ? pathArray.slice(0, -1) : pathArray;
  let value = entry;
  for (const key of pathArray) {
    value = value[key];
  }
  return value;
}
function runValidators(tasks, entry, context) {
  let done = false;
  return tasks.reduce(function(previous, next) {
    if (done) {
      return previous;
    }
    return previous.then(function(error) {
      if (error) {
        done = true;
        return error;
      }
      return next(entry, context);
    }).catch(function(error) {
      if (error) {
        done = true;
        return error;
      }
      return next(entry, context);
    });
  }, Promise.resolve());
}
function isNil(entry) {
  return !!(entry === void 0 || entry === null);
}

// src/NopeObject.ts
var NopeObject = class {
  constructor(objectShape) {
    this.validationRules = [];
    this._type = "object";
    this.objectShape = objectShape || {};
  }
  getType() {
    return this._type;
  }
  shape(shape) {
    Object.assign(this.objectShape, shape);
    return this;
  }
  extend(Base) {
    Object.assign(this.objectShape, Base.objectShape);
    return this;
  }
  noUnknown(message = "Input contains invalid keys") {
    const rule = (entry) => {
      let objectIsDefined = false;
      for (const _ in this.objectShape) {
        objectIsDefined = true;
        break;
      }
      if (!objectIsDefined) {
        throw Error("noUnknown must be used with a schema");
      }
      let unknownKeys = false;
      for (const key in entry) {
        unknownKeys = unknownKeys || !(key in this.objectShape);
      }
      if (unknownKeys) {
        return message;
      }
    };
    this.validationRules.push(rule);
    return this;
  }
  validate(entry, context, options) {
    for (const rule of this.validationRules) {
      const localErrors = rule(entry);
      if (localErrors) {
        return localErrors;
      }
    }
    let areErrors = false;
    const abortEarly = options?.abortEarly;
    const errors = {};
    const ctx = Object.assign({ ___parent: context }, entry);
    for (const key in this.objectShape) {
      const validator = this.objectShape[key];
      const error = validator.validate(entry[key], ctx, options);
      if (error) {
        areErrors = true;
        errors[key] = error;
        if (abortEarly) {
          return errors;
        }
      }
    }
    if (areErrors) {
      return errors;
    }
    return void 0;
  }
  validateAsync(entry, context, options) {
    return runValidators(this.validationRules, entry, context).then((localError) => {
      if (localError) {
        return localError;
      }
      const keys = [];
      const results = [];
      const ctx = Object.assign({ ___parent: context }, entry);
      for (const key in this.objectShape) {
        const validator = this.objectShape[key];
        const error = validator.validateAsync(entry[key], ctx, options);
        keys.push(key);
        results.push(error);
      }
      return Promise.all(results).then((resolvedErrors) => {
        const errors = {};
        let areErrors = false;
        for (let i = 0; i < keys.length; i++) {
          const error = resolvedErrors[i];
          if (error) {
            areErrors = true;
            errors[keys[i]] = error;
          }
        }
        if (areErrors) {
          return errors;
        }
        return void 0;
      });
    });
  }
  validateAt(path, entry) {
    const arrayPath = pathToArray(path);
    let validator = this.objectShape;
    for (const p of arrayPath) {
      if (!isNaN(parseInt(p, 10))) {
        continue;
      }
      if (validator[p]?.objectShape) {
        validator = validator[p].objectShape;
      } else if (validator[p]?.ofShape) {
        validator = validator[p].ofShape.objectShape || validator[p].ofShape;
      } else {
        validator = validator[p];
      }
    }
    const parentValue = getFromPath(path, entry, true);
    const value = getFromPath(path, entry);
    return validator.validate(value, parentValue);
  }
};

// src/consts.ts
var emailRegex = /^(([^<>()[\]\.,;:\s@\"]+(\.[^<>()[\]\.,;:\s@\"]+)*)|(\".+\"))@(([^<>()[\]\.,;:\s@\"]+\.)+[^<>()[\]\.,;:\s@\"]{2,})$/i;
var urlRegex = /^([a-z][a-z0-9\*\-\.]*):\/\/(?:(?:(?:[\w\.\-\+!$&'\(\)*\+,;=]|%[0-9a-f]{2})+:)*(?:[\w\.\-\+%!$&'\(\)*\+,;=]|%[0-9a-f]{2})+@)?(?:(?:[a-z0-9\-\.]|%[0-9a-f]{2})+|(?:\[(?:[0-9a-f]{0,4}:)*(?:[0-9a-f]{0,4})\]))(?::[0-9]+)?(?:[\/|\?](?:[\w#!:\.\?\+=&@!$'~*,;\/\(\)\[\]\-]|%[0-9a-f]{2})*)?$/i;

// src/NopePrimitive.ts
var NopePrimitive = class _NopePrimitive {
  constructor() {
    this.validationRules = [];
    this._type = "undefined";
  }
  getType() {
    return this._type;
  }
  isEmpty(entry) {
    return isNil(entry);
  }
  required(message = "This field is required") {
    const rule = (entry) => {
      if (this.isEmpty(entry)) {
        return message;
      }
    };
    return this.test(rule);
  }
  notAllowed(message = "Field is not allowed") {
    const rule = (entry) => {
      if (!this.isEmpty(entry)) {
        return message;
      }
    };
    return this.test(rule);
  }
  when(keys, conditionObject) {
    const ctxKeys = Array.isArray(keys) ? keys : [keys];
    const rule = (_, context) => {
      const resolvedConditionValues = resolveNopeRefsFromKeys(ctxKeys, context);
      const values = [...resolvedConditionValues];
      const condIs = conditionObject.is;
      const result = typeof condIs === "function" ? condIs(...values) : resolvedConditionValues.every((val) => val === condIs);
      return result ? conditionObject.then : conditionObject.otherwise;
    };
    return this.test(rule);
  }
  oneOf(options, message = "Invalid option") {
    const rule = (entry, context) => {
      if (entry === void 0) {
        return;
      }
      let resolved;
      if (options instanceof NopeReference) {
        resolved = resolveNopeRef(options, context);
      } else {
        resolved = options.map((option) => resolveNopeRef(option, context));
      }
      if (resolved.indexOf(entry) === -1) {
        return message;
      }
    };
    return this.test(rule);
  }
  notOneOf(options, message = "Invalid Option") {
    const rule = (entry, context) => {
      const resolvedOptions = options.map((option) => resolveNopeRef(option, context));
      if (resolvedOptions.indexOf(entry) !== -1) {
        return message;
      }
    };
    return this.test(rule);
  }
  test(rule) {
    this.validationRules.push(rule);
    return this;
  }
  /**
   * @param entry - The value to be validated
   * @param context - Used for internal reference resolving. Do not pass this.
   */
  validate(entry, context) {
    this._entry = entry;
    for (const rule of this.validationRules) {
      const error = rule(this._entry, context);
      if (error instanceof _NopePrimitive) {
        return error.validate(this._entry, context);
      } else if (error) {
        return error;
      }
    }
  }
  validateAsync(entry, context) {
    return runValidators(this.validationRules, this._entry ?? entry, context).then((error) => {
      if (error instanceof _NopePrimitive) {
        return error.validateAsync(this._entry ?? entry, context);
      } else if (error) {
        return error;
      }
    });
  }
};

// src/NopeString.ts
var NopeString = class extends NopePrimitive {
  constructor() {
    super(...arguments);
    this._type = "string";
  }
  validate(entry, context) {
    const value = entry ? String(entry) : entry;
    return super.validate(value, context);
  }
  validateAsync(entry, context) {
    const value = entry ? String(entry) : entry;
    return super.validateAsync(value, context);
  }
  isEmpty(value) {
    return isNil(value) || value.trim().length === 0;
  }
  regex(regex, message = "Doesn't satisfy the rule") {
    const rule = (entry) => {
      if (this.isEmpty(entry)) {
        return;
      }
      if (!regex.test(entry)) {
        return message;
      }
    };
    return this.test(rule);
  }
  url(message = "Input is not a valid url") {
    this.regex(urlRegex, message);
    return this;
  }
  email(message = "Input is not a valid email") {
    this.regex(emailRegex, message);
    return this;
  }
  min(length, message) {
    this.atLeast(length, message);
    return this;
  }
  max(length, message) {
    this.atMost(length, message);
    return this;
  }
  greaterThan(length, message = "Input is too short") {
    const rule = (entry) => {
      if (this.isEmpty(entry)) {
        return;
      }
      const value = entry;
      if (value.length <= length) {
        return message;
      }
    };
    return this.test(rule);
  }
  lessThan(length, message = "Input is too long") {
    const rule = (entry) => {
      if (this.isEmpty(entry)) {
        return;
      }
      const value = entry;
      if (value.length >= length) {
        return message;
      }
    };
    return this.test(rule);
  }
  atLeast(length, message = "Input is too short") {
    const rule = (entry) => {
      if (this.isEmpty(entry)) {
        return;
      }
      const value = entry;
      if (value.length < length) {
        return message;
      }
    };
    return this.test(rule);
  }
  atMost(length, message = "Input is too long") {
    const rule = (entry) => {
      if (this.isEmpty(entry)) {
        return;
      }
      const value = entry;
      if (value.length > length) {
        return message;
      }
    };
    return this.test(rule);
  }
  between(startLength, endLength, atLeastMessage = "Input is too short", atMostMessage = "Input is too long") {
    if (startLength && endLength && startLength > endLength) {
      const rule = () => {
        throw Error(
          "between must receive an initial length (startLength) smaller than the final length (endLength) parameter"
        );
      };
      return this.test(rule);
    }
    this.atLeast(startLength, atLeastMessage);
    this.atMost(endLength, atMostMessage);
    return this;
  }
  exactLength(length, message = `Must be at exactly of length ${length}`) {
    const rule = (entry) => {
      if (this.isEmpty(entry)) {
        return;
      }
      const value = entry;
      if (value.length !== length) {
        return message;
      }
    };
    return this.test(rule);
  }
  trim() {
    const rule = (entry) => {
      this._entry = entry.trim();
      return;
    };
    return this.test(rule);
  }
};

// src/NopeNumber.ts
var NopeNumber = class extends NopePrimitive {
  constructor(message = "The field is not a valid number") {
    super();
    this.message = "The field is not a number";
    this._type = "number";
    this.message = message;
  }
  integer(message = "Input must be an integer") {
    const rule = (entry) => {
      if (this.isEmpty(entry)) {
        return;
      }
      if (entry !== Math.floor(entry)) {
        return message;
      }
    };
    return this.test(rule);
  }
  min(size, message) {
    this.atLeast(size, message);
    return this;
  }
  max(size, message) {
    this.atMost(size, message);
    return this;
  }
  greaterThan(size, message = "Input is too small") {
    const rule = (entry) => {
      if (this.isEmpty(entry)) {
        return;
      }
      if (entry <= size) {
        return message;
      }
    };
    return this.test(rule);
  }
  lessThan(size, message = "Input is too large") {
    const rule = (entry) => {
      if (this.isEmpty(entry)) {
        return;
      }
      if (entry >= size) {
        return message;
      }
    };
    return this.test(rule);
  }
  atLeast(size, message = "Input is too small") {
    const rule = (entry) => {
      if (this.isEmpty(entry)) {
        return;
      }
      if (entry < size) {
        return message;
      }
    };
    return this.test(rule);
  }
  atMost(size, message = "Input is too large") {
    const rule = (entry) => {
      if (this.isEmpty(entry)) {
        return;
      }
      if (entry > size) {
        return message;
      }
    };
    return this.test(rule);
  }
  between(sizeStart, sizeEnd, atLeastMessage = "Input is too small", atMostMessage = "Input is too large") {
    if (sizeStart && sizeEnd && sizeStart > sizeEnd) {
      const rule = () => {
        throw Error(
          "between must receive an initial size (sizeStart) smaller than the final size (sizeEnd) parameter"
        );
      };
      return this.test(rule);
    }
    this.atLeast(sizeStart, atLeastMessage);
    this.atMost(sizeEnd, atMostMessage);
    return this;
  }
  positive(message = "Input must be positive") {
    this.greaterThan(0, message);
    return this;
  }
  negative(message = "Input must be negative") {
    this.lessThan(0, message);
    return this;
  }
  validate(entry, context) {
    const value = entry ? Number(entry) : entry;
    if (!this.isEmpty(value) && Number.isNaN(value)) {
      return this.message;
    }
    return super.validate(value, context);
  }
  validateAsync(entry, context) {
    const value = entry ? Number(entry) : entry;
    if (!this.isEmpty(value) && Number.isNaN(value)) {
      return Promise.resolve(this.message);
    }
    return super.validateAsync(value, context);
  }
};

// src/NopeBoolean.ts
var NopeBoolean = class extends NopePrimitive {
  constructor() {
    super(...arguments);
    this._type = "boolean";
  }
  true(message = "Input must be true") {
    const rule = (entry) => {
      if (this.isEmpty(entry)) {
        return;
      }
      if (entry !== true) {
        return message;
      }
    };
    return this.test(rule);
  }
  false(message = "Input must be false") {
    const rule = (entry) => {
      if (this.isEmpty(entry)) {
        return;
      }
      if (entry !== false) {
        return message;
      }
    };
    return this.test(rule);
  }
  validate(entry, context) {
    const value = isNil(entry) ? entry : !!entry;
    return super.validate(value, context);
  }
  validateAsync(entry, context) {
    const value = isNil(entry) ? entry : !!entry;
    return super.validateAsync(value, context);
  }
};

// src/NopeArray.ts
function ofType(entry, primitive) {
  let done = false;
  return entry.reduce(function(previous, next) {
    if (done) {
      return previous;
    }
    return previous.then(function(error) {
      if (error) {
        done = true;
        return error;
      }
      return primitive.validateAsync(next);
    });
  }, Promise.resolve());
}
var NopeArray = class {
  constructor() {
    this._type = "object";
    this.validationRules = [];
    this.ofShape = null;
  }
  getType() {
    return this._type;
  }
  required(message = "This field is required") {
    const rule = (entry) => {
      if (isNil(entry)) {
        return message;
      }
    };
    return this.test(rule);
  }
  of(primitive, message = "One or more elements are of invalid type") {
    this.ofShape = primitive;
    const rule = (entry) => {
      if (isNil(entry)) {
        return;
      }
      if (entry.some((value) => primitive.getType() !== typeof value)) {
        return message;
      }
      const error = entry.find((value) => primitive.validate(value));
      if (error) {
        return message;
      }
    };
    return this.test(rule);
  }
  ofAsync(primitive, message = "One or more elements are of invalid type") {
    this.ofShape = primitive;
    const rule = (entry) => {
      if (isNil(entry)) {
        return;
      }
      if (entry.some((value) => primitive.getType() !== typeof value)) {
        return message;
      }
      return ofType(entry, primitive).then((error) => error && message || void 0);
    };
    return this.test(rule);
  }
  minLength(length, message = "Input is too short") {
    const rule = (entry) => {
      if (isNil(entry)) {
        return;
      }
      if (entry.length <= length) {
        return message;
      }
    };
    return this.test(rule);
  }
  maxLength(length, message = "Input is too long") {
    const rule = (entry) => {
      if (isNil(entry)) {
        return;
      }
      if (entry.length >= length) {
        return message;
      }
    };
    return this.test(rule);
  }
  mustContain(value, message = "Input does not contain required value") {
    const rule = (entry) => {
      if (isNil(entry)) {
        return;
      }
      if (entry.indexOf(value) === -1) {
        return message;
      }
    };
    return this.test(rule);
  }
  hasOnly(values, message = "Input elements must correspond to value values") {
    const rule = (entry) => {
      if (isNil(entry)) {
        return;
      }
      if (entry.some((value) => {
        if (typeof value === "object") {
          return !values.find((v) => deepEquals(value, v));
        }
        return values.indexOf(value) === -1;
      })) {
        return message;
      }
    };
    return this.test(rule);
  }
  every(callback, message = "Input does not satisfy condition") {
    const rule = (entry) => {
      if (isNil(entry)) {
        return;
      }
      if (entry.some((value) => !callback(value))) {
        return message;
      }
    };
    return this.test(rule);
  }
  some(callback, message = "Input does not satisfy condition") {
    const rule = (entry) => {
      if (isNil(entry) || entry.length === 0) {
        return;
      }
      if (!entry.some((value) => callback(value))) {
        return message;
      }
    };
    return this.test(rule);
  }
  test(rule) {
    this.validationRules.push(rule);
    return this;
  }
  validate(entry, context) {
    for (const rule of this.validationRules) {
      const error = rule(entry, context);
      if (error instanceof NopePrimitive) {
        return error.validate(entry, context);
      } else if (error) {
        return `${error}`;
      }
    }
  }
  validateAsync(entry, context) {
    return runValidators(this.validationRules, entry, context).then(
      (error) => {
        if (error instanceof NopePrimitive) {
          return error.validateAsync(entry, context);
        } else if (error) {
          return error;
        }
      }
    );
  }
};

// src/NopeDate.ts
var NopeDate = class extends NopePrimitive {
  constructor(message = "The field is not a valid date") {
    super();
    this._type = "object";
    this.message = message;
  }
  before(beforeDate, message = `Date must be before ${beforeDate.toString()}`) {
    const rule = (entry, context) => {
      if (this.isEmpty(entry)) {
        return;
      }
      const resolvedBeforeDate = beforeDate instanceof NopeReference && context ? context[beforeDate.key] : beforeDate;
      if (new Date(entry) >= new Date(resolvedBeforeDate)) {
        return message;
      }
    };
    return this.test(rule);
  }
  after(afterDate, message = `Date must be after ${afterDate}`) {
    const rule = (entry, context) => {
      if (this.isEmpty(entry)) {
        return;
      }
      const resolvedAfterDate = afterDate instanceof NopeReference && context ? context[afterDate.key] : afterDate;
      if (new Date(entry) <= new Date(resolvedAfterDate)) {
        return message;
      }
    };
    return this.test(rule);
  }
  parseDate(entry) {
    let value = entry;
    if (this.isEmpty(entry) || entry instanceof Date) {
      value = entry;
    } else if (!isNaN(+new Date(entry))) {
      value = new Date(entry);
    } else {
      const ms = new Date(entry);
      if (isNaN(+ms)) {
        throw this.message;
      }
      value = new Date(ms);
    }
    return value;
  }
  validate(entry, context) {
    let value;
    try {
      value = this.parseDate(entry);
    } catch (error) {
      return error;
    }
    return super.validate(value, context);
  }
  validateAsync(entry, context) {
    let value;
    try {
      value = this.parseDate(entry);
    } catch (error) {
      return Promise.resolve(error);
    }
    return super.validateAsync(value, context);
  }
};

// src/index.ts
var object = () => new NopeObject();
var string = () => new NopeString();
var number = (message) => new NopeNumber(message);
var boolean = () => new NopeBoolean();
var date = (message) => new NopeDate(message);
var array = () => new NopeArray();
var ref = (key) => new NopeReference(key);
var Nope = {
  object,
  string,
  number,
  boolean,
  date,
  array,
  ref
};
var index_default = Nope;

exports.Nope = Nope;
exports.array = array;
exports.boolean = boolean;
exports.date = date;
exports.default = index_default;
exports.number = number;
exports.object = object;
exports.ref = ref;
exports.string = string;
//# sourceMappingURL=index.js.map
//# sourceMappingURL=index.js.map